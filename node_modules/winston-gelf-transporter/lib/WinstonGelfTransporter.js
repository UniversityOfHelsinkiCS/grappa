"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const winston_transport_1 = __importDefault(require("winston-transport"));
const gelf_pro_1 = __importDefault(require("gelf-pro"));
const os_1 = __importDefault(require("os"));
const MIN_PORT = 0;
const MAX_PORT = 65535;
class WinstonGelfTransporter extends winston_transport_1.default {
    constructor(options) {
        super(options);
        this.logLevels = Object({
            emerg: 0,
            alert: 1,
            crit: 2,
            error: 3,
            warn: 4,
            notice: 5,
            info: 6,
            debug: 7
        });
        this.options = options;
        const logConfig = Object({ fields: {} });
        // Update protocol if provided
        if (options.protocol) {
            logConfig.adapterName = options.protocol;
        }
        // Update host and port information if provided
        if (options.port || options.host) {
            logConfig.adapterOptions = {};
            if (options.port &&
                options.port >= MIN_PORT &&
                options.port < MAX_PORT) {
                logConfig.adapterOptions.port = options.port;
            }
            if (options.host) {
                logConfig.adapterOptions.host = options.host;
            }
        }
        logConfig.fields = options.hostName
            ? { host: options.hostName }
            : { host: os_1.default.hostname() };
        if (options.additional) {
            logConfig.fields = Object.assign(Object.assign({}, logConfig.fields), options.additional);
        }
        this.objectSerializer = JSON.stringify;
        gelf_pro_1.default.setConfig(logConfig);
        this.gelfClient = gelf_pro_1.default;
    }
    /**
     * This function will return a network connector
     * for sending GELF messages.
     * @returns A TCP Client for graylog.
     */
    getNetworkConnector() {
        return this.gelfClient;
    }
    getLogLevel(level) {
        return this.logLevels[level];
    }
    setObjectSerializer(serializer) {
        this.objectSerializer = serializer;
    }
    getLogMessage(info) {
        let { message } = info;
        const logData = Object.assign({}, info);
        delete logData.message;
        delete logData.level;
        if (info.stack && typeof message === 'string') {
            // Info is an error, send an error object
            message = new Error(message);
            message.stack = info.stack;
        }
        else if (!(message instanceof Error)) {
            if (info.message instanceof Object) {
                // Message is an object, get string representation
                message = this.objectSerializer(message);
            }
            else if (Object.keys(logData).length) {
                // Got a message string with additional object param
                message = this.objectSerializer(Object.assign({ message }, logData));
            }
        }
        return message;
    }
    log(info, next) {
        const level = this.getLogLevel(info.level);
        if (this.level && level > this.getLogLevel(this.level)) {
            // Don't log if level is too high
            if (next) {
                next();
                return;
            }
            return;
        }
        const message = this.getLogMessage(info);
        this.gelfClient.message(message, this.getLogLevel(info.level), next);
    }
    close() {
        this.gelfClient.message('Connection closed', this.logLevels.info);
    }
}
exports.default = WinstonGelfTransporter;
//# sourceMappingURL=WinstonGelfTransporter.js.map